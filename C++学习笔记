C语言中如何理解指针？不少讲师说：指针就是地址，这样正确吗？

C++中可以对常量取地址吗？

C++ 中的引用

C++中函数为什么不要返回局部变量的引用？
都是局部变量了，你肯定不能返回了，函数内部的局部变量在函数运行完局部变量的权限就交还给系统了，
函数的形参相当于你调用函数的时候给函数的一个变量，并不是函数的，并不会随着函数的结束被释放掉，
因为这本来就不是函数的东西呀。

C++中开辟内存
指针 = (类型*)malloc(sizeof(类型))

int占多少字节？这个有一个作用就是区分当前系统是多少位
4个，short为2字节，char为1字节，

中文在不同编码下占2～4个字节
UTF-8编码是变长编码，通常汉字占三个字节，扩展B区以后的汉字占四个字节
GBK编码，一个汉字占两个字节
UTF-16编码，通常汉字占两个字节

函数指针/指针函数?
重点都在后两字
1.指针函数 _type_ *function(int,int)
_type_ *function(int,int) 和普通函数int function(int,int)类似
只是返回的数据类型不一样而已，_type_ *function(int, int)返回的是指针地址，int function(int，int)返回的是int型数据

2.函数指针_type_ (*function)(int,int)
_type_ (*function)(int,int)只是一个指针，变量指针是指向一个变量的地址，结构体指针是指向一个结构体的首地址，
而函数指针是指向一个函数的地址，它是一种类型，比int，char高级的类型。

为啥类里需要拷贝构造函数？
首先对普通类型的对象来说，它们之间的赋值是简单的，
如:int a = 100;int b = a;而类的对象与普通对象是不同的，类的对象内部结构一般比较复杂，存在各种成员变量
所以创建对象时，会用到拷贝构造函数

C++中的内存管理是怎样的？
https://www.cnblogs.com/learning-zjx/p/10645659.html

给字符串开辟内存时，末尾需要加1，字符串末尾有结束\0
(char *)malloc(strlen(name)+1)

类的四个重要函数：
无参构造
有参构造
拷贝构造
析构函数

当您有任何看法与我不一致，您是对的，我是错的。

C++中可以对常量取地址吗?
可以把~
比如 const int i=5; //常量
const int * j=&i;
还有 只要为常量分配了地址  为什么不能取呢??
不能取地址的是常数把  比如  15, 25 等

函数重载：同一作用域，函数名相同，参数个数，参数数据类型不同
作用域+返回类型+函数名+参数列表
无法按返回值类型区分
遇到默认参数的函数要注意二义性
实参的个数可以不等于形参吗？C++里不行

引用的使用一定要注意，必须初始化一个有效的内存。
而const int& i 会等价于开辟了临时内存

为什么要使用指针的引用？
防止多级指针的使用

///////////////////////////////////////////////////////////

int i=5,j=6;
const离谁近，就作用于谁。
const后的内容为不能修改的。
例如指针常量 int * const p = &a;则表示指针p的内容不能修改；常量指针int const *p = &a;则表示指针p所指向的内容不能修改。



const int* p1 = &i; //指向常量的指针
*p1=5;错误
p1=&j;正确



int* const p3 = &i;
p3=&j;


int* const p2 = &i;//常量指针
*p2=5;正确
p2=&j;错误

Android 系统仅仅是谷歌的一个项目，就像微信和腾讯的关系一样。

时间复杂度:是指执行算法所需要的计算工作量
和空间复杂度:指执行这个算法所需要的内存空间

隐式动画和显示动画：
隐式动画指的是改变属性值而产生的默认的过渡动画（如background、cornerRadius等），
不需要初始化任何类，系统自己处理的动画属性；
显式动画是指自己创建一个动画对象并附加到layer上，
如 CAAnimation、CABasicAnimation、CAKeyframeAnimation。

UIView是CALayer的代理怎么说？

冒泡排序：每次扫描假定是完全有序的，也就是在外层for循环搞一个true,只要进入内层就置false,然后在第一层if判断 break
这样能起到优化的作用，这种本来有序概率比较低
另外一种方案：
如果序列尾部已经局部有序，可以记录最后一次交换的位置，减少比较次数

选择排序
从序列中找出最大的元素，然后与最末尾的元素交换位置
接着在剩下的元素中寻找最大的

堆排序
选择排序的优化

数据结构+算法=程序
数据结构有：
线性结构（数组，链表，栈，队列，哈希表），
树形结构（AVL树，红黑树，B树，堆，Trie，哈夫曼树，并查集），
图形结构(邻接矩阵，邻接表)

复杂度
syso =>快捷打印
sout回车
斐波那契数
ctrl+1倒入
敲什么都有提示设置方法 preference->搜索content assitent
将这串拷贝过去
.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789

动态数组：自己写, 其实　Java自带ArrayList

自动登录(异步请求，需要考虑home页面的网络请求结果判断)
不需要跳过(需要考虑异地登录tokenId失效)


JS是20年前，10天内开发出来的语言。

如何对ArrayList扩容？
new 出来的是随机地址
java的泛型<>里面只能放对象类型，不支持int这样的基本数据类型


equals()
toString()

动态数组
链表 是一种链式存储的线性表，所有元素的内存地址不一定是连续的

Provisioning profile "xxx" doesn't include the com.apple.developer.aps-environment entitlement.

同一个包里面的类可以直接使用
java 里面可以写内部类

13.1 => 13916759474
13.6 => 18856425363

为什么 C++ 有指针了还要引用？
为了支持操作符重载
是这样的。一般来说指针和引用基本可以互换使用，这也是为什么 java 只有引用就够了。
c++ 指针的概念完全是因为 c 语言的历史遗留，为了兼容 c 而设计的。好的，那你会问，那为什么不直接用指针，还要搞个引用这种玩意？
这是因为 c++ 里有个叫运算符重载的东西，所以 *pointer 这个表达式很有可能并不是直接取值的意思，因为*被重载了。
你问我怎么会有这种鬼玩意？去看看 C++ RAII 的设计，对一个智能指针对象比如 scoped_ptr 取值得到的不是这个智能指针本身，
而是他所指向的对象的值，这听起来有些绕口。所以当遇到这个情况，我们需要一个备胎来代替*的作用，所以就有了引用这玩意，
C++ 的创始人可是真任性呢。C++ 是一种非常复杂的语言，很有可能是这个世界上最复杂的语言。它的复杂来自于他的灵活，一把锋利的双刃剑。

作者：马超
链接：https://www.zhihu.com/question/34988367/answer/68239930
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

C++ 类内实现和类外实现有什么区别？作用是什么？
调用方式不同，在类里面定义的是内联函数
//调用 的时候不发生控制权转移，作为函数体本身一个模块进行调用
在类外面定义的函数
//情况相反，调用 的时候需要开辟一部分空间
//总结就是类里面定义的调用更快，更节省内存

什么时候需要调用delete?
使用了new之后必须要调用delete

C++中形参前为啥要加const?
禁止修改

为什么要使用智能指针?
自动管理内存

Qt是一个跨平台C++图形用户界面应用程序框架

STL:标准模版库,提供了6大组件:容器，算法，迭代器，仿函数，适配器，空间配置器，

为什么要有vector容器？array的缺陷
动态分配内存，灵活性大

静态成员变量为什么在类内声明，类外初始化？作用域是本文件
静态成员属于全局变量，是所有实例化以后的对象所共享的，而成员的初始化你可以想象成向系统申请内存存储数据的过程，
显然这种共有对象必须提前申请好，而不是由某个实例化的对象来操纵的。

声明只是表明了变量的数据类型和属性，并不分配内存；定义则是需要分配内存的。
注意：如果在类里面这么写int a; 那么是既声明了变量，也定义了变量，两者合在一起了。
静态成员是“类级别”的，也就是它和类的地位等同，而普通成员是“对象（实例）级别”的。
类级别的成员，先于该类任何对象的存在而存在，它被该类所有的对象共享。
现在，咱们假定要实例化该类的一个对象，那么会发生什么事情呢？
静态成员肯定要出现在这个对象里面的，对吧？这时候才去定义那个静态成员吗？这显然是不合适的。


 这会产生两种可能的情况：
 A. 重复定义；
 B. 就算不产生重复定义的情况，也会产生竞争，从而造成死锁的问题，以至于对象无法创建。
很显然，编译器不能这么干。那么很合理的解决办法，就是事先在类的外部把它定义好，然后再供所有的对象共享。
当然这样做，还是有可能产生线程安全的问题，但不管怎么说对象是创建好了，而这种线程安全问题，可以在编程中予以解决。
既然statci成员变量在类中只是声明那么就需要在类外部重新定义或者初始化。

C++空类中有哪些数据成员和成员函数，
C++空类大小为何是1？
每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，
这样空类在实例化后在内存得到了独一无二的地址．所以大小为１.
如果一个文件中定义了超过256个空类会出现什么问题?(这个是面试时，被问到的)

你定义了一个空类后，其实空类里面会自动生成一些内容的
class Empty {
 public: Empty(); // 缺省构造函数 (非虚)
 Empty(const Empty& rhs); // 拷贝构造函数
 ~Empty(); // 析构函数 ---- 一般非虚的（除非继承体系有虚函数）
 Empty &operator=(const Empty& rhs); // 赋值运算符
 Empty* operator&(); // 取址运算符 const Empty* operator&() const;
};
不难解释为何要占一个字节。
换个角度，倘若你不给他分一个字节，在下面你继承这个空类的时候，从哪里确定有这个父类呢？
第三个问题，没什么意义，如果非要说有什么问题，只能说你在程序定义了太多无用的东西而已。

在C语言程序中，数组名表示的是数组首个元素的地址

class 实例化用new和不用new的区别？
不用new在栈中分配内存,用new在堆中分配内存.new必须delete删除，不用new系统会自动回收内存

C++ 静态联编和动态联编
异常
输入输出

代码工具virtual studio Mac：https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio-mac/?sku=communitymac&rel=16

static 修饰的变量有什么特点
三元表达式“？:”问号后面的两个操作数必须为同一类型

先进后出，不一定要全部入栈之后再出栈，没入栈完也可以先出栈。
规律：
出栈的每一个元素的后面，其中比该元素先入栈的一定按照入栈逆顺序排列。
举例说明：
已知入栈顺序： 1 2 3 4 5
判断出栈顺序： 4 3 5 1 2
结果：不合理，原因是出栈元素3之后有 5 1 2 这三个元素，其中1 2 是比3先入栈的，根据规律，这两个出栈的顺序必须和入栈顺序相反，
也就是 2 1 出栈，不可能按照1 2 顺序出栈。

已知入栈顺序： 1 2 3 4 5
判断出栈顺序： 2 1 3 5 4
结果：合理，逐个判断，2后面比它先入栈的是“1”，单个元素当然可以；1后面无比它先入栈的，故不需要比较；3后面无比它先入栈的，故不需要比较；
5后面比它先入栈的是“4”，单个元素当然可以，4后面没有元素，不需要比较。

声明时，C和C++都可以省略形参名，但是通常不建议这样做。
在函数定义时，在C语言中，即使不使用形式参数，也不能省略参数名，而在C++中是可以的。
在Xcode中虽然你那没有报错 但是调用时省略的形参确实没有了。

函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。
重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。


使用Xcode 编写C++ new了之后没有delete 为什么不会报错？
没释放而已。不会出错，但是会继续占用系统资源。
现在的操作系统比较强大，进程结束之后就全回收了，不会带来什么严重的后果。
但是在程序中，建议不用了立即 delete 掉。否则资源用完了，后续的内存申请会失败。

C++用new和不用new创建类对象区别?
使用new, 必须配套使用delete，调用delete时才会调用析构函数
不用new, 析构函数会自动执行
一个使用堆内存，一个使用栈内存，那我们知道栈内存很有限，倘若只要是实例化就用栈内存，那肯定不行
所以我觉得这大概就是 "C++ 中既然不用new也能创建对象,那为什么还要用new呢?" 的原因吧

什么是虚函数?
在一个类的成员函数前面加上virtual，这个函数就成为了虚函数。虚函数的目的是在派生类中重写该函数，达到
父类指针指向子类对象的目的，如果实例化对象是父类，那么就调用父类的函数，如果是子类，那么就调用子类该函数
也就是多态。

子类必须重写虚函数吗？纯虚函数呢?
都不必，子类即使不重写，也不会报错.

想要实现多态，就要用到虚函数，多态是什么？
C++的多态性用一句话概括就是：
在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。
如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

多态中虚函数使用时的内存泄漏问题?
父类指针操作子类对象的成员函数的时候是没有问题的，
可是在销毁对象内存的时候则只是执行了父类的析构函数，子类的析构函数却没有执行，这会导致内存泄漏。
解决这个问题要用到虚析构函数virtual ~ClassName();

virtual关键字在使用时有哪些限制？
1.这个函数必须是某一个类的成员函数，不可以是一个全局函数，否则会导致编译错误。
2.静态成员函数不能是虚函数 static成员函数是和类同生共处的，他不属于任何对象，使用virtual也将导致错误。
3.内联函数不能是虚函数 如果修饰内联函数 如果内联函数被virtual修饰，计算机会忽略inline使它变成存粹的虚函数。
4.构造函数不能是虚函数，否则会出现编译错误。

那虚函数的实现原理是什么？
首先要说函数指针，多态的原理。
指针指向对象称为对象指针，指针除了指向对象还可以指向函数，函数的本质就是一段二进制代码，我们可以通过指针指向这段代码的开头，
计算机就会从这个开头一直往下执行，直到函数结束，并且通过指令返回回来。函数的指针与普通的指针本质上是一样的，
也是由四个基本的内存单元组成，存储着内存的地址，这个地址就是函数的首地址。
虚函数表指针：类中除了定义的函数成员，还有一个成员是虚函数表指针（占四个基本内存单元），
这个指针指向一个虚函数表的起始位置，这个表会与类的定义同时出现，这个表存放着该类的虚函数指针，
调用的时候可以找到该类的虚函数表指针，通过虚函数表指针找到虚函数表，通过虚函数表的偏移找到函数的入口地址，从而找到要使用的虚函数。
当实例化一个该类的子类对象的时候，（如果）该类的子类并没有定义虚函数，
但是却从父类中继承了虚函数，所以在实例化该类子类对象的时候也会产生一个虚函数表，
这个虚函数表是子类的虚函数表，但是记录的子类的虚函数地址却是与父类的是一样的。
所以通过子类对象的虚函数表指针找到自己的虚函数表，在自己的虚函数表找到的要执行的函数指针也是父类的相应函数入口的地址。
如果我们在子类中定义了从父类继承来的虚函数，对于父类来说情况是不变的，对于子类来说它的虚函数表与之前的虚函数表是一样的，
但是此时子类定义了自己的（从父类那继承来的）相应函数，所以它的虚函数表当中管于这个函数的指针就会覆盖掉原有的指向父类函数的指针的值，
换句话说就是指向了自己定义的相应函数，这样如果用父类的指针，指向子类的对象，就会通过子类对象当中的虚函数表指针找到子类的虚函数表，
从而通过子类的虚函数表找到子类的相应虚函数地址，而此时的地址已经是该函数自己定义的虚函数入口地址，而不是父类的相应虚函数入口地址，
所以执行的将会是子类当中的虚函数。这就是多态的原理。
如果父类当中定义了虚析构函数，那么父类的虚函数表当中就会有一个父类的虚析构函数的入口指针，
指向的是父类的虚析构函数，子类虚函数表当中也会产生一个子类的虚析构函数的入口指针，
指向的是子类的虚析构函数，这个时候使用父类的指针指向子类的对象，delete接父类指针，
就会通过指向的子类的对象找到子类的虚函数表指针，从而找到虚函数表，再虚函数表中找到子类的虚析构函数，
从而使得子类的析构函数得以执行，子类的析构函数执行之后系统会自动执行父类的虚析构函数。
这个是虚析构函数的实现原理。

内存的分配方式有几种？
一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。
二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效
率很高，但是分配的内存容量有限。
三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们
决定，使用非常灵活，但问题也最多。


Boost 中有智能指针 可以很好地避免内存泄漏方面地问题
始于1998年
asio
container
将近25个大类 128个类库
建议下70
1.架构分析
2.智能指针
3.文件系统
4.容器库
5.正则表达式
