C语言中如何理解指针？不少讲师说：指针就是地址，这样正确吗？

C++中可以对常量取地址吗？

C++ 中的引用

C++中函数为什么不要返回局部变量的引用？
都是局部变量了，你肯定不能返回了，函数内部的局部变量在函数运行完局部变量的权限就交还给系统了，
函数的形参相当于你调用函数的时候给函数的一个变量，并不是函数的，并不会随着函数的结束被释放掉，
因为这本来就不是函数的东西呀。

C++中开辟内存
指针 = (类型*)malloc(sizeof(类型))

int占多少字节？这个有一个作用就是区分当前系统是多少位
4个，short为2字节，char为1字节，

中文在不同编码下占2～4个字节
UTF-8编码是变长编码，通常汉字占三个字节，扩展B区以后的汉字占四个字节
GBK编码，一个汉字占两个字节
UTF-16编码，通常汉字占两个字节

函数指针/指针函数?
重点都在后两字
1.指针函数 _type_ *function(int,int)
_type_ *function(int,int) 和普通函数int function(int,int)类似
只是返回的数据类型不一样而已，_type_ *function(int, int)返回的是指针地址，int function(int，int)返回的是int型数据

2.函数指针_type_ (*function)(int,int)
_type_ (*function)(int,int)只是一个指针，变量指针是指向一个变量的地址，结构体指针是指向一个结构体的首地址，
而函数指针是指向一个函数的地址，它是一种类型，比int，char高级的类型。

为啥类里需要拷贝构造函数？
首先对普通类型的对象来说，它们之间的赋值是简单的，
如:int a = 100;int b = a;而类的对象与普通对象是不同的，类的对象内部结构一般比较复杂，存在各种成员变量
所以创建对象时，会用到拷贝构造函数

C++中的内存管理是怎样的？
https://www.cnblogs.com/learning-zjx/p/10645659.html

给字符串开辟内存时，末尾需要加1，字符串末尾有结束\0
(char *)malloc(strlen(name)+1)

类的四个重要函数：
无参构造
有参构造
拷贝构造
析构函数

当您有任何看法与我不一致，您是对的，我是错的。

C++中可以对常量取地址吗?
可以把~
比如 const int i=5; //常量
const int * j=&i;
还有 只要为常量分配了地址  为什么不能取呢??
不能取地址的是常数把  比如  15, 25 等

函数重载：函数名，参数个数，参数数据类型
无法按返回值类型区分
遇到默认参数的函数要注意二义性
实参的个数可以不等于形参吗？

引用的使用一定要注意，必须初始化一个有效的内存。
而const int& i 会等价于开辟了临时内存

为什么要使用指针的引用？
防止多级指针的使用

///////////////////////////////////////////////////////////

int i=5,j=6;
const离谁近，就作用于谁。
const后的内容为不能修改的。
例如指针常量 int * const p = &a;则表示指针p的内容不能修改；常量指针int const *p = &a;则表示指针p所指向的内容不能修改。



const int* p1 = &i; //指向常量的指针
*p1=5;错误
p1=&j;正确



int* const p3 = &i;
p3=&j;


int* const p2 = &i;//常量指针
*p2=5;正确
p2=&j;错误

Android 系统仅仅是谷歌的一个项目，就像微信和腾讯的关系一样。

时间复杂度:是指执行算法所需要的计算工作量
和空间复杂度:指执行这个算法所需要的内存空间

隐式动画和显示动画：
隐式动画指的是改变属性值而产生的默认的过渡动画（如background、cornerRadius等），
不需要初始化任何类，系统自己处理的动画属性；
显式动画是指自己创建一个动画对象并附加到layer上，
如 CAAnimation、CABasicAnimation、CAKeyframeAnimation。

UIView是CALayer的代理怎么说？

冒泡排序：每次扫描假定是完全有序的，也就是在外层for循环搞一个true,只要进入内层就置false,然后在第一层if判断 break
这样能起到优化的作用，这种本来有序概率比较低
另外一种方案：
如果序列尾部已经局部有序，可以记录最后一次交换的位置，减少比较次数

选择排序
从序列中找出最大的元素，然后与最末尾的元素交换位置
接着在剩下的元素中寻找最大的

堆排序
选择排序的优化

数据结构+算法=程序
数据结构有：
线性结构（数组，链表，栈，队列，哈希表），
树形结构（AVL树，红黑树，B树，堆，Trie，哈夫曼树，并查集），
图形结构(邻接矩阵，邻接表)

复杂度
syso =>快捷打印
斐波那契数
ctrl+1倒入
敲什么都有提示设置方法 preference->搜索content assitent
将这串拷贝过去
.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789

动态数组：自己写, 其实　Java自带ArrayList

自动登录(异步请求，需要考虑home页面的网络请求结果判断)
不需要跳过(需要考虑异地登录tokenId失效)


JS是20年前，10天内开发出来的语言。

如何对ArrayList扩容？
new 出来的是随机地址
java的泛型<>里面只能放对象类型，不支持int这样的基本数据类型


equals()
toString()

动态数组
链表 是一种链式存储的线性表，所有元素的内存地址不一定是连续的

Provisioning profile "xxx" doesn't include the com.apple.developer.aps-environment entitlement.

同一个包里面的类可以直接使用
java 里面可以写内部类

13.1 => 13916759474
13.6 => 18856425363

为什么 C++ 有指针了还要引用？
为了支持操作符重载
是这样的。一般来说指针和引用基本可以互换使用，这也是为什么 java 只有引用就够了。
c++ 指针的概念完全是因为 c 语言的历史遗留，为了兼容 c 而设计的。好的，那你会问，那为什么不直接用指针，还要搞个引用这种玩意？
这是因为 c++ 里有个叫运算符重载的东西，所以 *pointer 这个表达式很有可能并不是直接取值的意思，因为*被重载了。
你问我怎么会有这种鬼玩意？去看看 C++ RAII 的设计，对一个智能指针对象比如 scoped_ptr 取值得到的不是这个智能指针本身，
而是他所指向的对象的值，这听起来有些绕口。所以当遇到这个情况，我们需要一个备胎来代替*的作用，所以就有了引用这玩意，
C++ 的创始人可是真任性呢。C++ 是一种非常复杂的语言，很有可能是这个世界上最复杂的语言。它的复杂来自于他的灵活，一把锋利的双刃剑。

作者：马超
链接：https://www.zhihu.com/question/34988367/answer/68239930
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

C++ 类内实现和类外实现有什么区别？作用是什么？
调用方式不同，在类里面定义的是内联函数
//调用 的时候不发生控制权转移，作为函数体本身一个模块进行调用
在类外面定义的函数
//情况相反，调用 的时候需要开辟一部分空间
//总结就是类里面定义的调用更快，更节省内存

什么时候需要调用delete?
使用了new之后必须要调用delete

C++中形参前为啥要加const?
禁止修改

为什么要使用智能指针?
自动管理内存

Qt是一个跨平台C++图形用户界面应用程序框架

STL:标准模版库,提供了6大组件:容器，算法，迭代器，仿函数，适配器，空间配置器，

为什么要有vector容器？array的缺陷
动态分配内存，灵活性大

静态成员变量为什么在类内声明，类外初始化？作用域是本文件
声明只是表明了变量的数据类型和属性，并不分配内存；定义则是需要分配内存的。
注意：如果在类里面这么写int a; 那么是既声明了变量，也定义了变量，两者合在一起了。
静态成员是“类级别”的，也就是它和类的地位等同，而普通成员是“对象（实例）级别”的。
类级别的成员，先于该类任何对象的存在而存在，它被该类所有的对象共享。
现在，咱们假定要实例化该类的一个对象，那么会发生什么事情呢？
静态成员肯定要出现在这个对象里面的，对吧？这时候才去定义那个静态成员吗？这显然是不合适的。
因为，比如有另外一个线程也要创建该类的对象，那么也要按照这个方式去定义那个静态成员。

 这会产生两种可能的情况：
 A. 重复定义；
 B. 就算不产生重复定义的情况，也会产生竞争，从而造成死锁的问题，以至于对象无法创建。
很显然，编译器不能这么干。那么很合理的解决办法，就是事先在类的外部把它定义好，然后再供所有的对象共享。
当然这样做，还是有可能产生线程安全的问题，但不管怎么说对象是创建好了，而这种线程安全问题，可以在编程中予以解决。
既然statci成员变量在类中只是声明那么就需要在类外部重新定义或者初始化。

C++空类中有哪些数据成员和成员函数，
C++空类大小为何是1？
每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，
这样空类在实例化后在内存得到了独一无二的地址．所以大小为１.
如果一个文件中定义了超过256个空类会出现什么问题?(这个是面试时，被问到的)

你定义了一个空类后，其实空类里面会自动生成一些内容的
class Empty {
 public: Empty(); // 缺省构造函数 (非虚)
 Empty(const Empty& rhs); // 拷贝构造函数
 ~Empty(); // 析构函数 ---- 一般非虚的（除非继承体系有虚函数）
 Empty &operator=(const Empty& rhs); // 赋值运算符
 Empty* operator&(); // 取址运算符 const Empty* operator&() const;
};
不难解释为何要占一个字节。
换个角度，倘若你不给他分一个字节，在下面你继承这个空类的时候，从哪里确定有这个父类呢？
第三个问题，没什么意义，如果非要说有什么问题，只能说你在程序定义了太多无用的东西而已。

在C语言程序中，数组名表示的是数组首个元素的地址

class 实例化用new和不用new的区别？
不用new在栈中分配内存,用new在堆中分配内存.new必须delete删除，不用new系统会自动回收内存

C++ 静态联编和动态联编
异常
输入输出
